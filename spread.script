neighbours = scan();
neighbours[neighbours.length] = getHostname();
for (i = 0; i < neighbours.length; i++) {
	servername = neighbours[i];
	//saveguard
	if (servername == "home") {
		continue;
	}
	ram = getServerMaxRam(getHostname()) - getServerUsedRam(getHostname());
	//wie viele threads mindestens verfügbar
	threads_min = ram / neighbours.length; //UNFERTIG!!!!!!!!!!!!!!

	//root access?
	if (!hasRootAccess(servername)) {
		//hacking level ausreichend?
		if (getHackingLevel() < getServerRequiredHackingLevel(servername)) {
			tprint("Hackingskills insufficient to hack " + servername);
			continue;
		}
		//Zugriff auf die notwendige Anzahl an Ports erschaffen, dann NUKE.exe
		switch (getServerNumPortsRequired(servername)) {
			case 2:
				ftpcrack(servername);
			case 1:
				brutessh(servername);
			case 0:
				nuke(servername);
				break;
			default:
				tprint("Tools insufficient to break into " + servername)
		}
	}
	//das melken starten
	if (hasRootAccess(servername)) {
		//schon am melken?
		ram_check = ram >= getScriptRam("milk.script")
		if ((!isRunning("milk.script", getHostname(), servername))&&ram_check) {
			run("milk.script", 1, servername); //TODO: Anzahl threads abhängig von Server machen
		}
		//Skripte verbreiten
		files = ["milk.script", "spread.script"]
		scp(files, getHostname(), servername);
		//schon am spreaden?
		if (!isRunning("spread.script", servername)) {
			exec("spread.script", servername); //spread auf neuem server starten
		}
	}

}


ram = getServerMaxRam(getHostname()) - getServerUsedRam(getHostname());
//noch genug RAM?
if (ram < getScriptRam("milk.script")) {
		tprint("Operation Exceeded RAM available on " + getHostname() );
}
